(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

var _imgExtractor = _interopRequireDefault(require("./modules/img-extractor.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/////////////////////////////////////////////////////////
// https://ru.wikipedia.org/wiki/Список_MIME-типов
window.imgExtractor = new _imgExtractor.default({
  // container: '.item.first',
  rename: {// prefix: 'pref_',
    // suffix: '_suf'
  } // autodownload: true

}); // console.log(window.imgExtractor.getElements());
// console.log(window.imgExtractor.getItems());

console.log(imgExtractor); // window.imgExtractor.downloadAll();

},{"./modules/img-extractor.js":4}],2:[function(require,module,exports){
"use strict";

var _extend = _interopRequireDefault(require("./modules/extend"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var CSSinJSON =
/*#__PURE__*/
function () {
  function CSSinJSON() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, CSSinJSON);

    this.elems_selector = []; // Селекторы базовых элементов

    this.scoped_elems = []; // Сами базовые элементы

    this.scoped = false; // Флаг изоляции стилей

    this.style_obj = {}; // Объект стилей

    this.scopedId = ''; // Здесь будет сгенерированный id для изоляции стилей

    this.style_string = ''; // Здесь будут сгенерированные стили в виде строки

    this.indent = 4;
    this.Extend = _extend.default; // Плагин объединения объектов
    // Точка входа, принимает селектор(ы) базовых элементов

    this.init(options.scopedElem, options.style);
  } // Генератор рандомного числа


  _createClass(CSSinJSON, [{
    key: "rand",
    value: function rand(min, max) {
      var rand = Math.floor(min + Math.random() * (max + 1 - min));
      return rand;
    } // Конвертер camelCase в cebab-case

  }, {
    key: "camelToKebab",
    value: function camelToKebab(camel) {
      return camel.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    } // TODO: разобраться с этим методом
    // Метод расширения стилей, пока работает не правильно

  }, {
    key: "extend",
    value: function extend(obj1, obj2) {
      this.style_obj = this.Extend(obj1, obj2);
      this.style_string = this.jsonToStyle(this.style_obj, this.scopedId);
      this.updateStyleInject(this.style_string, this.scopedId);
      return this.style_string;
    } // Вставка новых стилей в готовый элемент style

  }, {
    key: "updateStyleInject",
    value: function updateStyleInject(style_content, scoped) {
      var stl = document.querySelector("#".concat(scoped));
      stl.textContent = style_content;
    }
  }, {
    key: "removeStyle",
    value: function removeStyle() {
      var parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document.head;
      var scoped = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scopedId;
      var style_elem = document.querySelector("#".concat(scoped));

      if (style_elem) {
        parent.removeChild(style_elem);
        this.scoped_elems.forEach(function (elem) {
          return elem.removeAttribute('data-scoped');
        });
        return true;
      }

      return false;
    }
  }, {
    key: "addStyle",
    value: function addStyle() {
      var style_elem = document.querySelector("#".concat(this.scopedId));

      if (!style_elem) {
        this.injectStyle(this.style_string, document.head, 'CSSinJSON_style', this.scopedId);
        this.addScopedAttr(this.scoped_elems);
        return true;
      }

      return false;
    } // Создание нового элемента style и заполнение его атрибутами и стилями

  }, {
    key: "injectStyle",
    value: function injectStyle() {
      var style_content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.style_string;
      var elem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.head;
      var class_name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'CSSinJSON_style';
      var scoped = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.scopedId;
      var stl = document.createElement('style');
      stl.id = scoped;
      stl.className = class_name;
      stl.textContent = style_content;
      elem.appendChild(stl);
    } // Подготовка селектора к использованию в регулярке

  }, {
    key: "prepareSelector",
    value: function prepareSelector(selector) {
      return selector.replace(/([\.\#])/gmi, '\\$1');
    } // Метод обработки селекторов для scoped-режима
    // Если селектор соответствует базовому, к нему допишется атрибут scoped
    // Если селектор не соответствует базовому, то он будет наследоваться от атрибута scoped

  }, {
    key: "scopeSelector",
    value: function scopeSelector(selector, str, scoped_attr) {
      if (selector === this.prepareSelector(selector) && str !== 'body') {
        return "".concat(scoped_attr, " ").concat(str);
      } else if (str === 'body') {
        return str;
      }

      var reg_str = "(?:^|[^\\ \\t])(".concat(this.prepareSelector(selector), ")(?=$|[\\s\\.\\#>])");
      var regex = new RegExp(reg_str, 'gm');
      var match, matches, str_before, str_after, lastIndex;

      while ((match = regex.exec(str)) !== null) {
        if (match.index === regex.lastIndex) {
          regex.lastIndex++;
        }

        matches = match.slice();
        lastIndex = regex.lastIndex;
        str_before = str.slice(0, regex.lastIndex - match[1].length);
        str_after = str.slice(regex.lastIndex);
        str = str_before + match[1].replace(regex, '$1' + scoped_attr) + str_after;
        regex.lastIndex += scoped_attr.length;
      } // console.log('lastIndex: ', lastIndex);


      str = lastIndex === undefined ? "".concat(scoped_attr, " ").concat(str) : str;
      return str;
    } // Метод для генерации селекторов с атрибутом scoped.
    // Разбирает несколько селекторов, указанных через запятую

  }, {
    key: "scopedSelectorGenerate",
    value: function scopedSelectorGenerate(selector) {
      var _this = this;

      var regex = /(,\s*\n*\t*)/gm;
      var selector_arr = selector.split(regex).filter(function (selector) {
        return selector.search(regex) === -1 ? true : false;
      });
      var scoped_attr = "[data-scoped=".concat(this.scopedId, "]");
      var new_selector = ''; // Цикл по селекторам, указанным в стилях через запятую

      selector_arr.forEach(function (selector) {
        // Если надо генерировать изолированные стили
        if (_this.scoped) {
          // Цикл по каждому базовому селектору
          var prev_inner_new_selector = '';

          _this.elems_selector.forEach(function (scoped_elem) {
            var inner_new_selector = '';
            inner_new_selector = _this.scopeSelector(scoped_elem, selector, scoped_attr) + ',\n'; // Проверка на то, чтобы не дублировались селекторы, если они совпадают во внутреннем цикле

            if (prev_inner_new_selector !== inner_new_selector) {
              new_selector += inner_new_selector;
              prev_inner_new_selector = inner_new_selector;
            }
          }); // Если НЕ надо генерировать изолированные стили

        } else {
          new_selector += "".concat(selector, ",\n");
        }
      });
      return new_selector.slice(0, -2);
    } // Генерирует строковые стили для одного селектора

  }, {
    key: "objToStyle",
    value: function objToStyle(selector, obj) {
      var style = '';

      for (var prop in obj) {
        style += "\n".concat(' '.repeat(this.indent)).concat(this.camelToKebab(prop), ": ").concat(obj[prop], ";");
      }

      return "".concat(this.scopedSelectorGenerate(selector), " {").concat(style, "\n}");
    } // Генерирует полные стили по входящему объекту

  }, {
    key: "jsonToStyle",
    value: function jsonToStyle(json) {
      var style = '';

      for (var selector in json) {
        style += this.objToStyle(selector, json[selector]) + '\n\n';
      }

      return style;
    } // Вешает на базовые элементы scoped-атрибут для изоляции стилей

  }, {
    key: "addScopedAttr",
    value: function addScopedAttr(elems) {
      var _this2 = this;

      elems.forEach(function (elem) {
        return elem.dataset.scoped = _this2.scopedId;
      });
    } // Находит все элементы, указанные в качестве базовых, собирает эти элементы и
    // их селекторы в соответствующие массивы 

  }, {
    key: "findScopedElems",
    value: function findScopedElems(selector) {
      var _this3 = this;

      var elems_of_selector;

      if (_typeof(selector) === 'object') {
        selector.forEach(function (element) {
          _this3.elems_selector.push(element);

          elems_of_selector = document.querySelectorAll(element);

          if (elems_of_selector !== null) {
            elems_of_selector.forEach(function (elem) {
              // elem.dataset.scoped = this.scopedId;
              _this3.scoped_elems.push(elem);
            });
          }
        });
      } else if (typeof selector === 'string') {
        this.elems_selector.push(selector);
        elems_of_selector = document.querySelectorAll(selector);

        if (elems_of_selector !== null) {
          elems_of_selector.forEach(function (elem) {
            // elem.dataset.scoped = this.scopedId;
            _this3.scoped_elems.push(elem);
          });
        }
      }
    }
  }, {
    key: "scopedInit",
    value: function scopedInit(selector) {
      this.findScopedElems(selector);

      if (this.scoped_elems.length > 0) {
        this.scoped = true;
        this.addScopedAttr(this.scoped_elems);
      }
    } // Генератор id для изоляции стилей - строка 10 символов в диапазоне a-z

  }, {
    key: "scopedIdGenerate",
    value: function scopedIdGenerate() {
      var id = '';

      for (var i = 0; i < 10; i++) {
        id += String.fromCharCode(this.rand(97, 122));
      }

      return id;
    } // Если получен JSON, то он парсится в объект

  }, {
    key: "prepareStyle",
    value: function prepareStyle(style) {
      if (typeof style === 'string') {
        try {
          this.style_obj = JSON.parse(style);
        } catch (err) {
          console.error('CSSinJSON: JSON.parse(style) error');
        }
      } else if (_typeof(style) === 'object') {
        this.style_obj = style;
      }
    }
  }, {
    key: "init",
    value: function init(selector, style) {
      // Если получен JSON, то он парсится в объект
      this.prepareStyle(style); // Сгенерировать scopedId

      this.scopedId = this.scopedIdGenerate(); // Если нужно, инициализирует scoped-систему

      this.scopedInit(selector); // Сгенерировать строку стилей из полученного объекта

      this.style_string = this.jsonToStyle(this.style_obj); // Вставить сгенерированные стили на страницу

      this.injectStyle(this.style_string, document.head, 'CSSinJSON_style', this.scopedId);
    }
  }]);

  return CSSinJSON;
}();

window.CSSinJSON = CSSinJSON;

},{"./modules/extend":3}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extend;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*Функция из jQuery для объединения объектов
 * var newObj = extend(obj_1, obj_2);
 *
 * Для рекурсивного объединения
 * var newObj = extend(true, obj_1, obj_2);
 *
 * Работа функции изменяет первый объект obj_1
 * newObj === obj_1
 */
function extend() {
  var options,
      name,
      src,
      copy,
      copyIsArray,
      clone,
      target = arguments[0] || {},
      i = 1,
      length = arguments.length,
      deep = false; // Handle a deep copy situation

  if (typeof target === "boolean") {
    deep = target; // Skip the boolean and the target

    target = arguments[i] || {};
    i++;
  } // Handle case when target is a string or something (possible in deep copy)


  if (_typeof(target) !== "object" && !isFunction(target)) {
    target = {};
  } // Extend jQuery itself if only one argument is passed


  if (i === length) {
    target = this;
    i--;
  }

  for (; i < length; i++) {
    // Only deal with non-null/undefined values
    if ((options = arguments[i]) != null) {
      // Extend the base object
      for (name in options) {
        src = target[name];
        copy = options[name]; // Prevent never-ending loop

        if (target === copy) {
          continue;
        } // Recurse if we're merging plain objects or arrays


        if (deep && copy && (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
          if (copyIsArray) {
            copyIsArray = false;
            clone = src && Array.isArray(src) ? src : [];
          } else {
            clone = src && isPlainObject(src) ? src : {};
          } // Never move original objects, clone them


          target[name] = extend(deep, clone, copy); // Don't bring in undefined values
        } else if (copy !== undefined) {
          target[name] = copy;
        }
      }
    }
  }

  function isPlainObject(obj) {
    var proto, Ctor; // Detect obvious negatives
    // Use toString instead of jQuery.type to catch host objects

    if (!obj || toString.call(obj) !== "[object Object]") {
      return false;
    }

    proto = getProto(obj); // Objects with no prototype (e.g., `Object.create( null )`) are plain

    if (!proto) {
      return true;
    } // Objects with prototype are plain iff they were constructed by a global Object function


    Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
    return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;

    function getProto(obj) {
      obj = obj || {};
      return obj.getPrototypeOf;
    }

    function class2type() {
      return {};
    }

    function hasOwn(class2type) {
      return class2type.hasOwnProperty;
    }

    function fnToString(hasOwn) {
      return hasOwn.toString;
    }
  } // Return the modified object


  return target;
}

;

},{}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _downloadjs = _interopRequireDefault(require("downloadjs"));

var _interface = _interopRequireDefault(require("./interface"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ImgExtractor =
/*#__PURE__*/
function () {
  function ImgExtractor() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ImgExtractor);

    this.container = params.container ? document.querySelector(params.container) : document;
    this.name_prefix = params.rename && params.rename.prefix ? params.rename.prefix : '';
    this.name_suffix = params.rename && params.rename.suffix ? params.rename.suffix : '';
    this.default_name_ext = 'svg';
    this.name_index = 0;
    this.autodownload = params.autodownload;
    this.elems = {};
    this.items = [];
    this.mime_type = {
      svg: 'image/svg+xml',
      png: 'image/png',
      jpg: 'image/jpeg',
      jpeg: 'image/jpeg',
      tiff: 'image/tiff',
      webp: 'image/webp'
    };
    this.interface = null;
    this.init();
  }

  _createClass(ImgExtractor, [{
    key: "_getTypeFilter",
    value: function _getTypeFilter() {
      var filter = {};

      for (var type in this.elems) {
        filter[type] = true;
      }

      return filter;
    }
  }, {
    key: "_buildName",
    value: function _buildName(elem) {
      var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.default_name_ext;
      var name = '';

      if (elem.id) {
        name = elem.id;
      } else if (elem.classList.value !== '') {
        name = elem.classList.value;
      } else {
        name = this.name_index++;
      }

      return "".concat(this.name_prefix).concat(name).concat(this.name_suffix, ".").concat(ext);
    } // Метод, собирающий инлайновые svg со страницы

  }, {
    key: "_collectInlineSvg",
    value: function _collectInlineSvg() {
      var _this = this;

      var ext = 'svg';
      this.elems[ext] = this.container.querySelectorAll('svg');
      this.elems[ext].forEach(function (elem) {
        var item = {};
        item.name = _this._buildName(elem, ext);
        item.content = elem.outerHTML;
        item.ext = ext;

        _this.items.push(item);
      });
    } // Метод загрузки всех собранных картинок

  }, {
    key: "downloadAll",
    value: function downloadAll() {
      var _this2 = this;

      this.items.forEach(function (item) {
        (0, _downloadjs.default)(item.content, item.name, _this2.mime_type[item.ext]);
      });
    } // Метод получения элементов, содержащих картинки

  }, {
    key: "getElements",
    value: function getElements() {
      return this.elems;
    } // Метод получения айтомов, содержащих объекты картинок, подготовленные к загрузке

  }, {
    key: "getItems",
    value: function getItems() {
      return this.items;
    }
  }, {
    key: "init",
    value: function init() {
      // Запуск сбора инлайновых svg
      this._collectInlineSvg(); // Если автоматический запуск скачивания всех найденных картинок включен,


      if (this.autodownload) {
        // то просто скачиваем их
        this.downloadAll(); // Если автоматическое скачивание выключено, 
      } else {
        // То инициализируем интерфейс
        this.interface = new _interface.default({
          layout_id: 'img_extractor_interface',
          items: this.getItems(),
          filter: this._getTypeFilter()
        });
        console.log(this.interface);
      }
    }
  }]);

  return ImgExtractor;
}();

exports.default = ImgExtractor;

},{"./interface":6,"downloadjs":7}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ImgExtractorInterfaceTemplates =
/*#__PURE__*/
function () {
  function ImgExtractorInterfaceTemplates() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ImgExtractorInterfaceTemplates);

    this.colors = {
      bg_container: 'rgba(0, 0, 0, .7)',
      text: 'rgb(195, 207, 224)',
      border: 'rgba(105, 109, 125, 0.4)',
      accent: '#ffc000',
      accent_alfa: 'rgba(255, 192, 0, .3)'
    };
  }

  _createClass(ImgExtractorInterfaceTemplates, [{
    key: "getLayoutTemplate",
    value: function getLayoutTemplate() {
      return "\n            <div class=\"interface_header\">\n                <div class=\"interface_hide\" title=\"\u0421\u0432\u0435\u0440\u043D\u0443\u0442\u044C \u043F\u0430\u043D\u0435\u043B\u044C \u0441\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u044F\">\n                    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"".concat(this.colors.text, "\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n                        <line x1=\"4\" y1=\"12\" x2=\"20\" y2=\"12\"/>\n                        <polyline points=\"14 6 20 12 14 18\"/>\n                    </svg>\n                </div>\n                <div class=\"header_text\">\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0434\u043B\u044F \u0441\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u044F</div>\n            </div>\n            \n            <div class=\"interface_content\"></div>");
    }
  }, {
    key: "getIcons",
    value: function getIcons() {
      var icons = {
        circleEmpty: '',
        okCircled: ''
      };
    }
  }, {
    key: "getFilterBtnTemplate",
    value: function getFilterBtnTemplate(filter_name) {
      var btn = document.createElement('div');
      btn.className = 'filter_btn active';
      btn.dataset.filter = filter_name;
      btn.textContent = ".".concat(filter_name);
      return btn;
    }
  }, {
    key: "getListItem",
    value: function getListItem(item) {
      return "<div>".concat(item.name, "</div>");
    }
  }, {
    key: "getCommonStyle",
    value: function getCommonStyle(vars) {
      var _ref;

      return _ref = {}, _defineProperty(_ref, vars.layout_id, {
        backgroundColor: this.colors.bg_container,
        boxShadow: "0 0 20px ".concat(this.colors.bg_container),
        color: this.colors.text,
        fontFamily: 'sans-serif',
        position: 'fixed',
        maxWidth: '500px',
        minWidth: '320px',
        width: '40%',
        height: '100vh',
        boxSizing: 'border-box',
        right: 0,
        top: 0,
        padding: '10px 15px',
        transform: 'translate3d(0, 0, 1px)',
        willChange: 'transform',
        transition: 'all .25s ease-in-out'
      }), _defineProperty(_ref, "".concat(vars.layout_id, ".close"), {
        transform: 'translate3d(100%, 0, 1px)',
        boxShadow: 'none'
      }), _defineProperty(_ref, '.interface_header', {
        display: 'flex',
        borderBottom: '1px solid ' + this.colors.border,
        marginBottom: '10px'
      }), _defineProperty(_ref, '.interface_hide', {
        padding: '10px',
        width: '28px',
        display: 'flex',
        justifyContent: 'center',
        cursor: 'pointer',
        transition: 'transform .25s ease-in-out'
      }), _defineProperty(_ref, '.interface_hide svg', {
        transition: 'transform .25s ease-in-out'
      }), _defineProperty(_ref, '.interface_hide:hover svg', {
        stroke: '#fff'
      }), _defineProperty(_ref, "".concat(vars.layout_id, ".close .interface_hide"), {
        'background-color': this.colors.bg_container,
        'border-radius': '5px 0 0 5px',
        transform: 'translate3d(calc(-100% - 15px), 0, 1px)'
      }), _defineProperty(_ref, "".concat(vars.layout_id, ".close .interface_hide svg"), {
        transform: 'rotate(180deg)'
      }), _defineProperty(_ref, '.header_text', {
        flexGrow: 1,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-around'
      }), _defineProperty(_ref, '.interface_content', {
        overflowY: 'auto'
      }), _defineProperty(_ref, '.filter_wrap', {
        display: 'flex',
        justifyContent: 'space-between',
        marginBottom: '10px'
      }), _defineProperty(_ref, '.filter_btn', {
        border: '1px solid',
        borderColor: this.colors.border,
        borderRadius: '2px',
        padding: '5px 10px',
        cursor: 'pointer',
        opacity: 0.8,
        userSelect: 'none'
      }), _defineProperty(_ref, '.filter_btn.active', {
        borderColor: this.colors.accent,
        color: this.colors.accent
      }), _defineProperty(_ref, '.list_item', {
        border: "1px solid",
        // borderColor: this.colors.border,
        borderColor: 'transparent',
        borderRadius: '3px',
        padding: '15px',
        marginBottom: '5px',
        backgroundColor: this.colors.bg_container,
        cursor: 'pointer',
        opacity: 0.5
      }), _defineProperty(_ref, ".list_item".concat(vars.list_item_slected), {
        // borderColor: this.colors.accent_alfa,
        borderColor: this.colors.border,
        opacity: 1
      }), _ref; // Конец стилей
    }
  }]);

  return ImgExtractorInterfaceTemplates;
}();

exports.default = ImgExtractorInterfaceTemplates;

},{}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../libs/CSSinJSON/app/js/css-in-json");

var _interfaceTemplates = _interopRequireDefault(require("./interface-templates"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ImgExtractorInterface =
/*#__PURE__*/
function () {
  function ImgExtractorInterface() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ImgExtractorInterface);

    var that = this;
    this.layout_id = params.layout_id;
    this.items = params.items;
    this._filter = params.filter;
    this.parts = {
      layout: null,
      header: null,
      content: null,
      filter: null,
      list: null
    };
    this.list_item_slected = 'selected';
    this.cssinjs = null;
    this.template = new _interfaceTemplates.default();
    this.state = {
      _opened: true,

      set opened(val) {
        if (typeof val === 'boolean') {
          this._opened = val;

          if (that.parts.layout) {
            val ? that.parts.layout.classList.remove('close') : that.parts.layout.classList.add('close');
          }
        }
      },

      get opened() {
        return this._opened;
      }

    }; // Точка входа

    this.init();
  }

  _createClass(ImgExtractorInterface, [{
    key: "_handlerListItemSelect",
    value: function _handlerListItemSelect(item) {
      item.classList.toggle(this.list_item_slected); // TODO: Здесь надо будет вызывать фильтрацию выбранных айтомов
    }
  }, {
    key: "_makeList",
    value: function _makeList() {
      this.parts.list = document.createElement('div');
      this.parts.list.className = 'list_wrap';
      this.parts.content.appendChild(this.parts.list);
    }
  }, {
    key: "_renderListItems",
    value: function _renderListItems(category) {
      var _this = this;

      var items = this.items.filter(function (item) {
        return item.ext === category;
      });
      items.forEach(function (item) {
        var list_item = document.createElement('div');
        list_item.className = "list_item ".concat(_this.list_item_slected);
        list_item.innerHTML = _this.template.getListItem(item);
        list_item.addEventListener('click', function (e) {
          _this._handlerListItemSelect(e.currentTarget);
        });

        _this.parts.list.appendChild(list_item);
      });
    }
  }, {
    key: "_clearListItems",
    value: function _clearListItems() {
      this.parts.list.innerHTML = '';
    }
  }, {
    key: "listRender",
    value: function listRender(filter_name) {
      var clear = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (clear) this._clearListItems();

      if (filter_name && this._filter[filter_name]) {
        this._renderListItems(filter_name);
      } else if (!filter_name) {
        this._clearListItems();

        for (var category in this._filter) {
          if (this._filter[category]) {
            this._renderListItems(category);
          }
        }
      }
    } // Метод, создающий блок с кнопками фильтра

  }, {
    key: "_makeFilter",
    value: function _makeFilter() {
      var _this2 = this;

      this.parts.filter = document.createElement('div');
      this.parts.filter.className = 'filter_wrap'; // Создаем кнопки по объекту фильтра

      for (var filter_name in this._filter) {
        var btn = this.template.getFilterBtnTemplate(filter_name); // Вешаем на полученные кнопки обработчик переключения фильтра

        btn.addEventListener('click', function (e) {
          var elem = e.currentTarget;

          var res = _this2.filter(elem.dataset.filter);

          res ? elem.classList.add('active') : elem.classList.remove('active');
        }); // Добавляем кнопку в контейнер

        this.parts.filter.appendChild(btn);
      } // вставляем контейнер фильтра в интерфейс


      this.parts.content.appendChild(this.parts.filter);
    } // Метод для изменения состояния фильтра

  }, {
    key: "filter",
    value: function filter(name, val) {
      if (val && typeof val === 'boolean') {
        this._filter[name] = val;
      } else if (val === undefined) {
        this._filter[name] = !this._filter[name];
      } // TODO: Тут надо будет запускать рендер фильтрации


      this.listRender();
      return this._filter[name];
    } // Метод для сворачивания/разворачивания интерфейса

  }, {
    key: "openToggle",
    value: function openToggle(e) {
      this.state.opened = !this.state.opened;

      if (e && this.state.opened) {
        e.currentTarget.setAttribute('title', 'Свернуть ImgExtractor');
      } else if (e && !this.state.opened) {
        e.currentTarget.setAttribute('title', 'Развернуть ImgExtractor');
      }
    } // Метод создания контейнера интерфейса

  }, {
    key: "_makeLayout",
    value: function _makeLayout() {
      var _this3 = this;

      this.parts.layout = document.createElement('div');
      this.parts.layout.id = this.layout_id;
      this.parts.layout.innerHTML = this.template.getLayoutTemplate(); // Сохраним в свойства шапку и контент интерфейса

      this.parts.header = this.parts.layout.querySelector('.interface_header');
      this.parts.content = this.parts.layout.querySelector('.interface_content'); // Вешаем обработчик на кнопку сворачивания/разворачивания интерфейса

      this.parts.layout.querySelector('.interface_hide').addEventListener('click', function (e) {
        _this3.openToggle(e);
      });
      document.body.appendChild(this.parts.layout);
    }
  }, {
    key: "init",
    value: function init() {
      // Создать контейнер интерфейса
      this._makeLayout(); // Создаем блок фильтра


      this._makeFilter(); // Создаем блок списка изображений


      this._makeList(); // Заполняем блок списка айтемами


      this.listRender(); // Добавить стили интерфейса на страницу, всегда в конце

      this.cssinjs = new CSSinJSON({
        style: this.template.getCommonStyle({
          layout_id: '#' + this.layout_id,
          list_item_slected: '.' + this.list_item_slected
        }),
        scopedElem: '#' + this.layout_id
      });
    }
  }]);

  return ImgExtractorInterface;
}();

exports.default = ImgExtractorInterface;

},{"../libs/CSSinJSON/app/js/css-in-json":2,"./interface-templates":5}],7:[function(require,module,exports){
//download.js v4.2, by dandavis; 2008-2016. [MIT] see http://danml.com/download.html for tests/usage
// v1 landed a FF+Chrome compat way of downloading strings to local un-named files, upgraded to use a hidden frame and optional mime
// v2 added named files via a[download], msSaveBlob, IE (10+) support, and window.URL support for larger+faster saves than dataURLs
// v3 added dataURL and Blob Input, bind-toggle arity, and legacy dataURL fallback was improved with force-download mime and base64 support. 3.1 improved safari handling.
// v4 adds AMD/UMD, commonJS, and plain browser support
// v4.1 adds url download capability via solo URL argument (same domain/CORS only)
// v4.2 adds semantic variable names, long (over 2MB) dataURL support, and hidden by default temp anchors
// https://github.com/rndme/download

(function (root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define([], factory);
	} else if (typeof exports === 'object') {
		// Node. Does not work with strict CommonJS, but
		// only CommonJS-like environments that support module.exports,
		// like Node.
		module.exports = factory();
	} else {
		// Browser globals (root is window)
		root.download = factory();
  }
}(this, function () {

	return function download(data, strFileName, strMimeType) {

		var self = window, // this script is only for browsers anyway...
			defaultMime = "application/octet-stream", // this default mime also triggers iframe downloads
			mimeType = strMimeType || defaultMime,
			payload = data,
			url = !strFileName && !strMimeType && payload,
			anchor = document.createElement("a"),
			toString = function(a){return String(a);},
			myBlob = (self.Blob || self.MozBlob || self.WebKitBlob || toString),
			fileName = strFileName || "download",
			blob,
			reader;
			myBlob= myBlob.call ? myBlob.bind(self) : Blob ;
	  
		if(String(this)==="true"){ //reverse arguments, allowing download.bind(true, "text/xml", "export.xml") to act as a callback
			payload=[payload, mimeType];
			mimeType=payload[0];
			payload=payload[1];
		}


		if(url && url.length< 2048){ // if no filename and no mime, assume a url was passed as the only argument
			fileName = url.split("/").pop().split("?")[0];
			anchor.href = url; // assign href prop to temp anchor
		  	if(anchor.href.indexOf(url) !== -1){ // if the browser determines that it's a potentially valid url path:
        		var ajax=new XMLHttpRequest();
        		ajax.open( "GET", url, true);
        		ajax.responseType = 'blob';
        		ajax.onload= function(e){ 
				  download(e.target.response, fileName, defaultMime);
				};
        		setTimeout(function(){ ajax.send();}, 0); // allows setting custom ajax headers using the return:
			    return ajax;
			} // end if valid url?
		} // end if url?


		//go ahead and download dataURLs right away
		if(/^data:([\w+-]+\/[\w+.-]+)?[,;]/.test(payload)){
		
			if(payload.length > (1024*1024*1.999) && myBlob !== toString ){
				payload=dataUrlToBlob(payload);
				mimeType=payload.type || defaultMime;
			}else{			
				return navigator.msSaveBlob ?  // IE10 can't do a[download], only Blobs:
					navigator.msSaveBlob(dataUrlToBlob(payload), fileName) :
					saver(payload) ; // everyone else can save dataURLs un-processed
			}
			
		}else{//not data url, is it a string with special needs?
			if(/([\x80-\xff])/.test(payload)){			  
				var i=0, tempUiArr= new Uint8Array(payload.length), mx=tempUiArr.length;
				for(i;i<mx;++i) tempUiArr[i]= payload.charCodeAt(i);
			 	payload=new myBlob([tempUiArr], {type: mimeType});
			}		  
		}
		blob = payload instanceof myBlob ?
			payload :
			new myBlob([payload], {type: mimeType}) ;


		function dataUrlToBlob(strUrl) {
			var parts= strUrl.split(/[:;,]/),
			type= parts[1],
			decoder= parts[2] == "base64" ? atob : decodeURIComponent,
			binData= decoder( parts.pop() ),
			mx= binData.length,
			i= 0,
			uiArr= new Uint8Array(mx);

			for(i;i<mx;++i) uiArr[i]= binData.charCodeAt(i);

			return new myBlob([uiArr], {type: type});
		 }

		function saver(url, winMode){

			if ('download' in anchor) { //html5 A[download]
				anchor.href = url;
				anchor.setAttribute("download", fileName);
				anchor.className = "download-js-link";
				anchor.innerHTML = "downloading...";
				anchor.style.display = "none";
				document.body.appendChild(anchor);
				setTimeout(function() {
					anchor.click();
					document.body.removeChild(anchor);
					if(winMode===true){setTimeout(function(){ self.URL.revokeObjectURL(anchor.href);}, 250 );}
				}, 66);
				return true;
			}

			// handle non-a[download] safari as best we can:
			if(/(Version)\/(\d+)\.(\d+)(?:\.(\d+))?.*Safari\//.test(navigator.userAgent)) {
				if(/^data:/.test(url))	url="data:"+url.replace(/^data:([\w\/\-\+]+)/, defaultMime);
				if(!window.open(url)){ // popup blocked, offer direct download:
					if(confirm("Displaying New Document\n\nUse Save As... to download, then click back to return to this page.")){ location.href=url; }
				}
				return true;
			}

			//do iframe dataURL download (old ch+FF):
			var f = document.createElement("iframe");
			document.body.appendChild(f);

			if(!winMode && /^data:/.test(url)){ // force a mime that will download:
				url="data:"+url.replace(/^data:([\w\/\-\+]+)/, defaultMime);
			}
			f.src=url;
			setTimeout(function(){ document.body.removeChild(f); }, 333);

		}//end saver




		if (navigator.msSaveBlob) { // IE10+ : (has Blob, but not a[download] or URL)
			return navigator.msSaveBlob(blob, fileName);
		}

		if(self.URL){ // simple fast and modern way using Blob and URL:
			saver(self.URL.createObjectURL(blob), true);
		}else{
			// handle non-Blob()+non-URL browsers:
			if(typeof blob === "string" || blob.constructor===toString ){
				try{
					return saver( "data:" +  mimeType   + ";base64,"  +  self.btoa(blob)  );
				}catch(y){
					return saver( "data:" +  mimeType   + "," + encodeURIComponent(blob)  );
				}
			}

			// Blob but not URL support:
			reader=new FileReader();
			reader.onload=function(e){
				saver(this.result);
			};
			reader.readAsDataURL(blob);
		}
		return true;
	}; /* end download() */
}));

},{}]},{},[1])

//# sourceMappingURL=maps/app.min.js.map
