{"version":3,"sources":["node_modules/browser-pack/_prelude.js","app/js/css-in-json.js","app/js/modules/extend.js"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","_extend","CSSinJSON","options","arguments","undefined","_classCallCheck","this","elems_selector","scoped_elems","scoped","style_obj","scopedId","style_string","indent","Extend","default","init","scopedElem","style","min","max","rand","Math","floor","random","camel","replace","toLowerCase","obj1","obj2","jsonToStyle","updateStyleInject","style_content","document","querySelector","concat","textContent","parent","head","style_elem","removeChild","forEach","elem","removeAttribute","injectStyle","addScopedAttr","class_name","stl","createElement","id","className","appendChild","selector","str","scoped_attr","prepareSelector","match","str_before","str_after","lastIndex","reg_str","regex","RegExp","exec","index","slice","_this","selector_arr","split","filter","search","new_selector","prev_inner_new_selector","scoped_elem","inner_new_selector","scopeSelector","obj","prop","repeat","camelToKebab","scopedSelectorGenerate","json","objToStyle","elems","_this2","dataset","elems_of_selector","_this3","_typeof","element","push","querySelectorAll","findScopedElems","String","fromCharCode","JSON","parse","err","console","error","prepareStyle","scopedIdGenerate","scopedInit","window","extend","name","src","copy","copyIsArray","clone","target","deep","isFunction","isPlainObject","Array","isArray","proto","Ctor","toString","getProto","hasOwn","constructor","fnToString","ObjectFunctionString","getPrototypeOf","class2type","hasOwnProperty"],"mappings":"CAAA,SAAAA,EAAAC,EAAAC,EAAAC,GAAA,SAAAC,EAAAC,EAAAC,GAAA,IAAAJ,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,IAAAE,EAAA,mBAAAC,SAAAA,QAAA,IAAAF,GAAAC,EAAA,OAAAA,EAAAF,GAAA,GAAA,GAAAI,EAAA,OAAAA,EAAAJ,GAAA,GAAA,IAAAK,EAAA,IAAAC,MAAA,uBAAAN,EAAA,KAAA,MAAAK,EAAAE,KAAA,mBAAAF,EAAA,IAAAG,EAAAX,EAAAG,GAAA,CAAAS,QAAA,IAAAb,EAAAI,GAAA,GAAAU,KAAAF,EAAAC,QAAA,SAAAd,GAAA,OAAAI,EAAAH,EAAAI,GAAA,GAAAL,IAAAA,IAAAa,EAAAA,EAAAC,QAAAd,EAAAC,EAAAC,EAAAC,GAAA,OAAAD,EAAAG,GAAAS,QAAA,IAAA,IAAAL,EAAA,mBAAAD,SAAAA,QAAAH,EAAA,EAAAA,EAAAF,EAAAa,OAAAX,IAAAD,EAAAD,EAAAE,IAAA,OAAAD,EAAA,CAAA,CAAAa,EAAA,CAAA,SAAAT,EAAAU,EAAAJ,gBCAA,MAAAK,KAAAX,EAAA,gcAGMY,aACF,SAAAA,IAA0B,IAAdC,EAAc,EAAAC,UAAAN,aAAAO,IAAAD,UAAA,GAAAA,UAAA,GAAJ,gGAAIE,CAAAC,KAAAL,GACtBK,KAAKC,eAAiB,GACtBD,KAAKE,aAAe,GACpBF,KAAKG,QAAS,EACdH,KAAKI,UAAY,GACjBJ,KAAKK,SAAW,GAChBL,KAAKM,aAAe,GACpBN,KAAKO,OAAS,EAGdP,KAAKQ,OAASd,EAAAe,QAIdT,KAAKU,KAAKd,EAAQe,WAAYf,EAAQgB,2DAIrCC,EAAKC,GACN,IAAIC,EAAOC,KAAKC,MAAMJ,EAAMG,KAAKE,UAAYJ,EAAM,EAAID,IACvD,OAAOE,uCAIEI,GACT,OAAOA,EAAMC,QAAQ,kBAAmB,SAASC,6CAK9CC,EAAMC,GAKT,OAJAvB,KAAKI,UAAYJ,KAAKQ,OAAOc,EAAMC,GACnCvB,KAAKM,aAAeN,KAAKwB,YAAYxB,KAAKI,UAAWJ,KAAKK,UAC1DL,KAAKyB,kBAAkBzB,KAAKM,aAAcN,KAAKK,UAExCL,KAAKM,uDAIEoB,EAAevB,GACnBwB,SAASC,cAAT,IAAAC,OAA2B1B,IACjC2B,YAAcJ,wCAGsC,IAAhDK,EAAgD,EAAAlC,UAAAN,aAAAO,IAAAD,UAAA,GAAAA,UAAA,GAAvC8B,SAASK,KAAM7B,EAAwB,EAAAN,UAAAN,aAAAO,IAAAD,UAAA,GAAAA,UAAA,GAAfG,KAAKK,SAC1C4B,EAAaN,SAASC,cAAT,IAAAC,OAA2B1B,IAC5C,QAAI8B,IACAF,EAAOG,YAAYD,GACnBjC,KAAKE,aAAaiC,QAAQ,SAAAC,GAAI,OAAIA,EAAKC,gBAAgB,kBAChD,sCAQX,OADiBV,SAASC,cAAT,IAAAC,OAA2B7B,KAAKK,aAE7CL,KAAKsC,YAAYtC,KAAKM,aAAcqB,SAASK,KAAM,kBAAmBhC,KAAKK,UAC3EL,KAAKuC,cAAcvC,KAAKE,eACjB,yCAO8G,IAAjHwB,EAAiH,EAAA7B,UAAAN,aAAAO,IAAAD,UAAA,GAAAA,UAAA,GAAjGG,KAAKM,aAAc8B,EAA8E,EAAAvC,UAAAN,aAAAO,IAAAD,UAAA,GAAAA,UAAA,GAAvE8B,SAASK,KAAMQ,EAAwD,EAAA3C,UAAAN,aAAAO,IAAAD,UAAA,GAAAA,UAAA,GAA3C,kBAAmBM,EAAwB,EAAAN,UAAAN,aAAAO,IAAAD,UAAA,GAAAA,UAAA,GAAfG,KAAKK,SAC3GoC,EAAMd,SAASe,cAAc,SACjCD,EAAIE,GAAKxC,EACTsC,EAAIG,UAAYJ,EAChBC,EAAIX,YAAcJ,EAClBU,EAAKS,YAAYJ,2CAILK,GACZ,OAAOA,EAAS1B,QAAQ,cAAe,8CAM7B0B,EAAUC,EAAKC,GACzB,GAAIF,IAAa9C,KAAKiD,gBAAgBH,IAAqB,SAARC,EAC/C,MAAA,GAAAlB,OAAUmB,EAAV,KAAAnB,OAAyBkB,GACtB,GAAY,SAARA,EACP,OAAOA,EAMX,IAJA,IAGIG,EAAgBC,EAAYC,EAAWC,EAHvCC,EAAO,mBAAAzB,OAAsB7B,KAAKiD,gBAAgBH,GAA3C,uBACPS,EAAQ,IAAIC,OAAOF,EAAS,MAGK,QAA7BJ,EAAQK,EAAME,KAAKV,KACnBG,EAAMQ,QAAUH,EAAMF,WACtBE,EAAMF,YAGAH,EAAMS,QAEhBN,EAAYE,EAAMF,UAClBF,EAAaJ,EAAIY,MAAM,EAAGJ,EAAMF,UAAYH,EAAM,GAAG3D,QACrD6D,EAAYL,EAAIY,MAAMJ,EAAMF,WAE5BN,EAAMI,EAAaD,EAAM,GAAG9B,QAAQmC,EAAO,KAAOP,GAAeI,EACjEG,EAAMF,WAAaL,EAAYzD,OAOnC,OAHAwD,OAAqBjD,IAAduD,EAAD,GAAAxB,OAA+BmB,EAA/B,KAAAnB,OAA8CkB,GAAQA,iDAQzCD,GAAU,IAAAc,EAAA5D,KACzBuD,EAAQ,iBACRM,EAAef,EAASgB,MAAMP,GAAOQ,OAAO,SAAAjB,GAAQ,OAAiC,IAA5BA,EAASkB,OAAOT,KACzEP,EAAW,gBAAAnB,OAAmB7B,KAAKK,SAAxB,KACX4D,EAAe,GA0BnB,OAvBAJ,EAAa1B,QAAQ,SAAAW,GAEjB,GAAIc,EAAKzD,OAAQ,CAGb,IAAI+D,EAA0B,GAC9BN,EAAK3D,eAAekC,QAAQ,SAAAgC,GACxB,IAAIC,EACJA,EAAqBR,EAAKS,cAAcF,EAAarB,EAAUE,GAAe,MAG1EkB,IAA4BE,IAC5BH,GAAgBG,EAChBF,EAA0BE,UAMlCH,GAAY,GAAApC,OAAOiB,EAAP,SAIbmB,EAAaN,MAAM,GAAI,sCAIvBb,EAAUwB,GACjB,IAAI1D,EAAQ,GACZ,IAAK,IAAI2D,KAAQD,EACb1D,GAAK,KAAAiB,OAAS,IAAI2C,OAAOxE,KAAKO,SAAzBsB,OAAmC7B,KAAKyE,aAAaF,GAArD,MAAA1C,OAA+DyC,EAAIC,GAAnE,KAGT,MAAA,GAAA1C,OAAU7B,KAAK0E,uBAAuB5B,GAAtC,MAAAjB,OAAoDjB,EAApD,2CAMQ+D,GACR,IAAI/D,EAAQ,GACZ,IAAK,IAAIkC,KAAY6B,EACjB/D,GAASZ,KAAK4E,WAAW9B,EAAU6B,EAAK7B,IAAa,OAGzD,OAAOlC,wCAIGiE,GAAO,IAAAC,EAAA9E,KACjB6E,EAAM1C,QAAQ,SAAAC,GAAI,OAAIA,EAAK2C,QAAQ5E,OAAS2E,EAAKzE,mDAKrCyC,GAAU,IAClBkC,EADkBC,EAAAjF,KAEE,WAApBkF,EAAOpC,GACPA,EAASX,QAAQ,SAAAgD,GACbF,EAAKhF,eAAemF,KAAKD,GAEC,QAD1BH,EAAoBrD,SAAS0D,iBAAiBF,KAE1CH,EAAkB7C,QAAQ,SAAAC,GAEtB6C,EAAK/E,aAAakF,KAAKhD,OAIR,iBAAbU,IACd9C,KAAKC,eAAemF,KAAKtC,GAGC,QAF1BkC,EAAoBrD,SAAS0D,iBAAiBvC,KAG1CkC,EAAkB7C,QAAQ,SAAAC,GAEtB6C,EAAK/E,aAAakF,KAAKhD,yCAM5BU,GACP9C,KAAKsF,gBAAgBxC,GACU,EAA3B9C,KAAKE,aAAaX,SAClBS,KAAKG,QAAS,EACdH,KAAKuC,cAAcvC,KAAKE,0DAO5B,IADA,IAAIyC,EAAK,GACA/D,EAAI,EAAGA,EAAI,GAAIA,IACpB+D,GAAM4C,OAAOC,aAAaxF,KAAKe,KAAK,GAAI,MAG5C,OAAO4B,uCAIE/B,GACT,GAAqB,iBAAVA,EACP,IAAMZ,KAAKI,UAAYqF,KAAKC,MAAM9E,GAAS,MAAO+E,GAAOC,QAAQC,MAAM,0CAC/C,WAAjBX,EAAOtE,KACdZ,KAAKI,UAAYQ,gCAKpBkC,EAAUlC,GAEXZ,KAAK8F,aAAalF,GAElBZ,KAAKK,SAAWL,KAAK+F,mBAErB/F,KAAKgG,WAAWlD,GAGhB9C,KAAKM,aAAeN,KAAKwB,YAAYxB,KAAKI,WAG1CJ,KAAKsC,YAAYtC,KAAKM,aAAcqB,SAASK,KAAM,kBAAmBhC,KAAKK,+CAInF4F,OAAOtG,UAAYA,2VClPJ,SAASuG,IACpB,IAAItG,EAASuG,EAAMC,EAAKC,EAAMC,EAAaC,EACvCC,EAAS3G,UAAU,IAAM,GACzBjB,EAAI,EACJW,EAASM,UAAUN,OACnBkH,GAAO,EAEW,kBAAXD,IACPC,EAAOD,EAEPA,EAAS3G,UAAUjB,IAAM,GACzBA,KAGkB,WAAlBsG,EAAOsB,IAAwBE,WAAWF,KAC1CA,EAAS,IAGT5H,IAAMW,IACNiH,EAASxG,KACTpB,KAEJ,KAAOA,EAAIW,EAAQX,IAEf,GAAgC,OAA3BgB,EAAUC,UAAUjB,IAErB,IAAKuH,KAAQvG,EACTwG,EAAMI,EAAOL,GACbE,EAAOzG,EAAQuG,GAEXK,IAAWH,IAIXI,GAAQJ,IAASM,EAAcN,KAC1BC,EAAcM,MAAMC,QAAQR,MAG7BE,EAFAD,GACAA,GAAc,EACNF,GAAOQ,MAAMC,QAAQT,GAAOA,EAAM,IAElCA,GAAOO,EAAcP,GAAOA,EAAM,GAG9CI,EAAOL,GAAQD,EAAOO,EAAMF,EAAOF,SAEnBvG,IAATuG,IACPG,EAAOL,GAAQE,IAM/B,SAASM,EAAcrC,GACnB,IAAIwC,EAAOC,EAGX,SAAKzC,GAA8B,oBAAvB0C,SAAS1H,KAAKgF,QAG1BwC,EAAQG,EAAS3C,KAOM,mBADvByC,EAAOG,EAAO5H,KAAKwH,EAAO,gBAAkBA,EAAMK,cACbC,EAAW9H,KAAKyH,KAAUM,sBAE/D,SAASJ,EAAS3C,GAEd,OADAA,EAAMA,GAAO,IACFgD,eAOf,SAASJ,EAAOK,GACZ,OAAOA,EAAWC,eAGtB,SAASJ,EAAWF,GAChB,OAAOA,EAAOF,UAKtB,OAAOR","file":"../css-in-json.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","import Extend from './modules/extend';\r\n\r\n\r\nclass CSSinJSON {\r\n    constructor(options = {}) {\r\n        this.elems_selector = []; // Селекторы базовых элементов\r\n        this.scoped_elems = []; // Сами базовые элементы\r\n        this.scoped = false; // Флаг изоляции стилей\r\n        this.style_obj = {}; // Объект стилей\r\n        this.scopedId = ''; // Здесь будет сгенерированный id для изоляции стилей\r\n        this.style_string = ''; // Здесь будут сгенерированные стили в виде строки\r\n        this.indent = 4;\r\n\r\n\r\n        this.Extend = Extend; // Плагин объединения объектов\r\n\r\n\r\n        // Точка входа, принимает селектор(ы) базовых элементов\r\n        this.init(options.scopedElem, options.style);\r\n    }\r\n\r\n    // Генератор рандомного числа\r\n    rand(min, max) {\r\n        let rand = Math.floor(min + Math.random() * (max + 1 - min));\r\n        return rand;\r\n    }\r\n\r\n    // Конвертер camelCase в cebab-case\r\n    camelToKebab(camel) {\r\n        return camel.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\r\n    }\r\n\r\n    // TODO: разобраться с этим методом\r\n    // Метод расширения стилей, пока работает не правильно\r\n    extend(obj1, obj2) {\r\n        this.style_obj = this.Extend(obj1, obj2);\r\n        this.style_string = this.jsonToStyle(this.style_obj, this.scopedId);\r\n        this.updateStyleInject(this.style_string, this.scopedId);\r\n\r\n        return this.style_string;\r\n    }\r\n\r\n    // Вставка новых стилей в готовый элемент style\r\n    updateStyleInject(style_content, scoped) {\r\n        let stl = document.querySelector(`#${scoped}`);\r\n        stl.textContent = style_content;\r\n    }\r\n\r\n    removeStyle(parent = document.head, scoped = this.scopedId) {\r\n        let style_elem = document.querySelector(`#${scoped}`);\r\n        if (style_elem) {\r\n            parent.removeChild(style_elem);\r\n            this.scoped_elems.forEach(elem => elem.removeAttribute('data-scoped'));\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    addStyle() {\r\n        let style_elem = document.querySelector(`#${this.scopedId}`);\r\n        if (!style_elem) {\r\n            this.injectStyle(this.style_string, document.head, 'CSSinJSON_style', this.scopedId);\r\n            this.addScopedAttr(this.scoped_elems);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // Создание нового элемента style и заполнение его атрибутами и стилями\r\n    injectStyle(style_content = this.style_string, elem = document.head, class_name = 'CSSinJSON_style', scoped = this.scopedId) {\r\n        let stl = document.createElement('style');\r\n        stl.id = scoped;\r\n        stl.className = class_name;\r\n        stl.textContent = style_content;\r\n        elem.appendChild(stl);\r\n    }\r\n\r\n    // Подготовка селектора к использованию в регулярке\r\n    prepareSelector(selector) {\r\n        return selector.replace(/([\\.\\#])/gmi, '\\\\$1');\r\n    }\r\n\r\n    // Метод обработки селекторов для scoped-режима\r\n    // Если селектор соответствует базовому, к нему допишется атрибут scoped\r\n    // Если селектор не соответствует базовому, то он будет наследоваться от атрибута scoped\r\n    scopeSelector(selector, str, scoped_attr) {\r\n        if (selector === this.prepareSelector(selector) && str !== 'body') {\r\n            return `${scoped_attr} ${str}`;\r\n        } else if (str === 'body') {\r\n            return str;\r\n        }\r\n        let reg_str = `(?:^|[^\\\\ \\\\t])(${this.prepareSelector(selector)})(?=$|[\\\\s\\\\.\\\\#>])`;\r\n        let regex = new RegExp(reg_str, 'gm');\r\n\r\n        let match, matches, str_before, str_after, lastIndex;\r\n        while ((match = regex.exec(str)) !== null) {\r\n            if (match.index === regex.lastIndex) {\r\n                regex.lastIndex++;\r\n            }\r\n\r\n            matches = match.slice();\r\n\r\n            lastIndex = regex.lastIndex;\r\n            str_before = str.slice(0, regex.lastIndex - match[1].length);\r\n            str_after = str.slice(regex.lastIndex);\r\n\r\n            str = str_before + match[1].replace(regex, '$1' + scoped_attr) + str_after;\r\n            regex.lastIndex += scoped_attr.length;\r\n        }\r\n\r\n        // console.log('lastIndex: ', lastIndex);\r\n        str = (lastIndex === undefined) ? `${scoped_attr} ${str}` : str;\r\n\r\n\r\n        return str;\r\n    }\r\n\r\n    // Метод для генерации селекторов с атрибутом scoped.\r\n    // Разбирает несколько селекторов, указанных через запятую\r\n    scopedSelectorGenerate(selector) {\r\n        let regex = /(,\\s*\\n*\\t*)/gm;\r\n        let selector_arr = selector.split(regex).filter(selector => (selector.search(regex) === -1) ? true : false);\r\n        let scoped_attr = `[data-scoped=${this.scopedId}]`;\r\n        let new_selector = '';\r\n\r\n        // Цикл по селекторам, указанным в стилях через запятую\r\n        selector_arr.forEach(selector => {\r\n            // Если надо генерировать изолированные стили\r\n            if (this.scoped) {\r\n\r\n                // Цикл по каждому базовому селектору\r\n                let prev_inner_new_selector = '';\r\n                this.elems_selector.forEach(scoped_elem => {\r\n                    let inner_new_selector = '';\r\n                    inner_new_selector = this.scopeSelector(scoped_elem, selector, scoped_attr) + ',\\n';\r\n\r\n                    // Проверка на то, чтобы не дублировались селекторы, если они совпадают во внутреннем цикле\r\n                    if (prev_inner_new_selector !== inner_new_selector) {\r\n                        new_selector += inner_new_selector;\r\n                        prev_inner_new_selector = inner_new_selector;\r\n                    }\r\n                });\r\n\r\n                // Если НЕ надо генерировать изолированные стили\r\n            } else {\r\n                new_selector += `${selector},\\n`;\r\n            }\r\n        })\r\n\r\n        return new_selector.slice(0, -2);\r\n    }\r\n\r\n    // Генерирует строковые стили для одного селектора\r\n    objToStyle(selector, obj) {\r\n        let style = '';\r\n        for (let prop in obj) {\r\n            style += `\\n${' '.repeat(this.indent)}${this.camelToKebab(prop)}: ${obj[prop]};`\r\n        }\r\n\r\n        return `${this.scopedSelectorGenerate(selector)} {${style}\\n}`;\r\n\r\n\r\n    }\r\n\r\n    // Генерирует полные стили по входящему объекту\r\n    jsonToStyle(json) {\r\n        let style = '';\r\n        for (let selector in json) {\r\n            style += this.objToStyle(selector, json[selector]) + '\\n\\n';\r\n        }\r\n\r\n        return style;\r\n    }\r\n\r\n    // Вешает на базовые элементы scoped-атрибут для изоляции стилей\r\n    addScopedAttr(elems) {\r\n        elems.forEach(elem => elem.dataset.scoped = this.scopedId)\r\n    }\r\n\r\n    // Находит все элементы, указанные в качестве базовых, собирает эти элементы и\r\n    // их селекторы в соответствующие массивы \r\n    findScopedElems(selector) {\r\n        let elems_of_selector;\r\n        if (typeof selector === 'object') {\r\n            selector.forEach(element => {\r\n                this.elems_selector.push(element);\r\n                elems_of_selector = document.querySelectorAll(element);\r\n                if (elems_of_selector !== null) {\r\n                    elems_of_selector.forEach(elem => {\r\n                        // elem.dataset.scoped = this.scopedId;\r\n                        this.scoped_elems.push(elem);\r\n                    })\r\n                }\r\n            });\r\n        } else if (typeof selector === 'string') {\r\n            this.elems_selector.push(selector);\r\n            elems_of_selector = document.querySelectorAll(selector);\r\n\r\n            if (elems_of_selector !== null) {\r\n                elems_of_selector.forEach(elem => {\r\n                    // elem.dataset.scoped = this.scopedId;\r\n                    this.scoped_elems.push(elem);\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    scopedInit(selector) {\r\n        this.findScopedElems(selector);\r\n        if (this.scoped_elems.length > 0) {\r\n            this.scoped = true;\r\n            this.addScopedAttr(this.scoped_elems);\r\n        }\r\n    }\r\n\r\n    // Генератор id для изоляции стилей - строка 10 символов в диапазоне a-z\r\n    scopedIdGenerate() {\r\n        let id = '';\r\n        for (let i = 0; i < 10; i++) {\r\n            id += String.fromCharCode(this.rand(97, 122));\r\n        }\r\n\r\n        return id;\r\n    }\r\n\r\n    // Если получен JSON, то он парсится в объект\r\n    prepareStyle(style) {\r\n        if (typeof style === 'string') {\r\n            try { this.style_obj = JSON.parse(style) } catch (err) { console.error('CSSinJSON: JSON.parse(style) error') }\r\n        } else if (typeof style === 'object') {\r\n            this.style_obj = style;\r\n        }\r\n    }\r\n\r\n\r\n    init(selector, style) {\r\n        // Если получен JSON, то он парсится в объект\r\n        this.prepareStyle(style)\r\n            // Сгенерировать scopedId\r\n        this.scopedId = this.scopedIdGenerate();\r\n        // Если нужно, инициализирует scoped-систему\r\n        this.scopedInit(selector);\r\n\r\n        // Сгенерировать строку стилей из полученного объекта\r\n        this.style_string = this.jsonToStyle(this.style_obj);\r\n\r\n        // Вставить сгенерированные стили на страницу\r\n        this.injectStyle(this.style_string, document.head, 'CSSinJSON_style', this.scopedId);\r\n    }\r\n}\r\n\r\nwindow.CSSinJSON = CSSinJSON;","/*Функция из jQuery для объединения объектов\r\n * var newObj = extend(obj_1, obj_2);\r\n *\r\n * Для рекурсивного объединения\r\n * var newObj = extend(true, obj_1, obj_2);\r\n *\r\n * Работа функции изменяет первый объект obj_1\r\n * newObj === obj_1\r\n */\r\n\r\n\r\nexport default function extend() {\r\n    var options, name, src, copy, copyIsArray, clone,\r\n        target = arguments[0] || {},\r\n        i = 1,\r\n        length = arguments.length,\r\n        deep = false;\r\n    // Handle a deep copy situation\r\n    if (typeof target === \"boolean\") {\r\n        deep = target;\r\n        // Skip the boolean and the target\r\n        target = arguments[i] || {};\r\n        i++;\r\n    }\r\n    // Handle case when target is a string or something (possible in deep copy)\r\n    if (typeof target !== \"object\" && !isFunction(target)) {\r\n        target = {};\r\n    }\r\n    // Extend jQuery itself if only one argument is passed\r\n    if (i === length) {\r\n        target = this;\r\n        i--;\r\n    }\r\n    for (; i < length; i++) {\r\n        // Only deal with non-null/undefined values\r\n        if ((options = arguments[i]) != null) {\r\n            // Extend the base object\r\n            for (name in options) {\r\n                src = target[name];\r\n                copy = options[name];\r\n                // Prevent never-ending loop\r\n                if (target === copy) {\r\n                    continue;\r\n                }\r\n                // Recurse if we're merging plain objects or arrays\r\n                if (deep && copy && (isPlainObject(copy) ||\r\n                        (copyIsArray = Array.isArray(copy)))) {\r\n                    if (copyIsArray) {\r\n                        copyIsArray = false;\r\n                        clone = src && Array.isArray(src) ? src : [];\r\n                    } else {\r\n                        clone = src && isPlainObject(src) ? src : {};\r\n                    }\r\n                    // Never move original objects, clone them\r\n                    target[name] = extend(deep, clone, copy);\r\n                    // Don't bring in undefined values\r\n                } else if (copy !== undefined) {\r\n                    target[name] = copy;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function isPlainObject(obj) {\r\n        var proto, Ctor;\r\n        // Detect obvious negatives\r\n        // Use toString instead of jQuery.type to catch host objects\r\n        if (!obj || toString.call(obj) !== \"[object Object]\") {\r\n            return false;\r\n        }\r\n        proto = getProto(obj);\r\n        // Objects with no prototype (e.g., `Object.create( null )`) are plain\r\n        if (!proto) {\r\n            return true;\r\n        }\r\n        // Objects with prototype are plain iff they were constructed by a global Object function\r\n        Ctor = hasOwn.call(proto, \"constructor\") && proto.constructor;\r\n        return typeof Ctor === \"function\" && fnToString.call(Ctor) === ObjectFunctionString;\r\n\r\n        function getProto(obj) {\r\n            obj = obj || {};\r\n            return obj.getPrototypeOf;\r\n        }\r\n\r\n        function class2type() {\r\n            return {};\r\n        }\r\n\r\n        function hasOwn(class2type) {\r\n            return class2type.hasOwnProperty;\r\n        }\r\n\r\n        function fnToString(hasOwn) {\r\n            return hasOwn.toString;\r\n        }\r\n    }\r\n\r\n    // Return the modified object\r\n    return target;\r\n};"]}